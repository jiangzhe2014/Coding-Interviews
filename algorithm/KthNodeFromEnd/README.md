## Description
```
输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。
例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6.这个链表的倒数第3个结点是值为4的结点。
```
## Solution
定义两个指针，第一个指针从链表的头指针开始遍历往前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。
由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针指向的正好是倒数第k个结点。<br>
要注意k的大小，链表头指针是否为空，及k是否大于链表的长度等问题。<br>
**相关问题：**
* 求链表的中间节点。如果链表中结点总数为奇数，返回中间结点；如果结点总数为偶数，返回中间两个结点的任意一个。解决方法是定义两个指针
，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的结点走到链表的末尾时，走的慢的指针正好在链表的中间。
* 判断一个单向链表是否形成了环形结构。和前面一个问题一样，定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次
走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走的快的指针走到了链表的末尾都没有追上第一个指针，那么链表就
不是环形链表。

## Code
```
public class KthNodeFromEnd{
    public ListNode FindKthToTail(ListNode head,int k) {
		if(head == null || k<=0)
            return null;
        ListNode node = head;
        //如果链表长度小于k，返回null
        for(int i=0; i<k-1; i++){
            if(head.next!=null)
                head = head.next;
            else
                return null;
        }
        while(head.next != null){
            head = head.next;
            node = node.next;
        }
        return node;
    }
}
```
